/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * audioserve API
 * REST API for audioserve
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://audioserve.zderadicka.eu".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AudioFile
 */
export interface AudioFile {
    /**
     * 
     * @type {string}
     * @memberof AudioFile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AudioFile
     */
    path: string;
    /**
     * 
     * @type {AudioFileMeta}
     * @memberof AudioFile
     */
    meta?: AudioFileMeta;
    /**
     * Mime type of audio file (before transcoding)
     * @type {string}
     * @memberof AudioFile
     */
    mime: string;
    /**
     * 
     * @type {AudioFileSection}
     * @memberof AudioFile
     */
    section?: AudioFileSection;
}
/**
 * 
 * @export
 * @interface AudioFileMeta
 */
export interface AudioFileMeta {
    /**
     * Duration of audio file in seconds
     * @type {number}
     * @memberof AudioFileMeta
     */
    duration?: number;
    /**
     * Encoding bitrate of file - original, before transcoding
     * @type {number}
     * @memberof AudioFileMeta
     */
    bitrate?: number;
    /**
     * Metadata tags as map of name to value
     * @type {any}
     * @memberof AudioFileMeta
     */
    tags?: any;
}
/**
 * For chapter chunk out from big chaptered file (like .m4b)  this is start and duration (in milliseconds) of chapter with the that file 
 * @export
 * @interface AudioFileSection
 */
export interface AudioFileSection {
    /**
     * Start of chapter in ms
     * @type {number}
     * @memberof AudioFileSection
     */
    start?: number;
    /**
     * Duration of chapter in ms
     * @type {number}
     * @memberof AudioFileSection
     */
    duration?: number;
}
/**
 * 
 * @export
 * @interface AudioFolder
 */
export interface AudioFolder {
    /**
     * Is virtual folder - e.g. representing big chapterized file (.m4b etc.)
     * @type {boolean}
     * @memberof AudioFolder
     */
    isFile?: boolean;
    /**
     * last modification timestamp (unix time in miliseconds)
     * @type {number}
     * @memberof AudioFolder
     */
    modified?: number;
    /**
     * Total playback time of the audiofolder in seconds
     * @type {number}
     * @memberof AudioFolder
     */
    totalTime?: number;
    /**
     * 
     * @type {Array<Subfolder>}
     * @memberof AudioFolder
     */
    subfolders?: Array<Subfolder>;
    /**
     * 
     * @type {Array<AudioFile>}
     * @memberof AudioFolder
     */
    files?: Array<AudioFile>;
    /**
     * 
     * @type {TypedFile}
     * @memberof AudioFolder
     */
    cover?: TypedFile;
    /**
     * 
     * @type {TypedFile}
     * @memberof AudioFolder
     */
    description?: TypedFile;
    /**
     * Metadata tags for this folders - map of name to value
     * @type {any}
     * @memberof AudioFolder
     */
    tags?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Names of available collections
     * @type {Array<string>}
     * @memberof InlineResponse200
     */
    names?: Array<string>;
    /**
     * Size of names array
     * @type {number}
     * @memberof InlineResponse200
     */
    count?: number;
    /**
     * Is folder download endpoint enabled on server?
     * @type {boolean}
     * @memberof InlineResponse200
     */
    folderDownload?: boolean;
    /**
     * Is playback position API enabled on server?
     * @type {boolean}
     * @memberof InlineResponse200
     */
    sharedPositions?: boolean;
    /**
     * Version of audioserve (and thus also version of API)
     * @type {string}
     * @memberof InlineResponse200
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Transcoding}
     * @memberof InlineResponse2001
     */
    high?: Transcoding;
    /**
     * 
     * @type {Transcoding}
     * @memberof InlineResponse2001
     */
    low?: Transcoding;
    /**
     * 
     * @type {Transcoding}
     * @memberof InlineResponse2001
     */
    medium?: Transcoding;
    /**
     * Maximum number of parallel transcodings allowed by server
     * @type {number}
     * @memberof InlineResponse2001
     */
    maxTranscodings?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
}
/**
 * Playback position
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * Position timestamp - unix time in ms Timestamp is generated on server, so if you post new  position  it is used to check, if there is not newer position,  but actual value then is assigned by server
     * @type {number}
     * @memberof Position
     */
    timestamp: number;
    /**
     * Collection number (index in names from response in /collections endpoint)
     * @type {number}
     * @memberof Position
     */
    collection: number;
    /**
     * Audio folder path
     * @type {string}
     * @memberof Position
     */
    folder: string;
    /**
     * Audio file (or chapter)
     * @type {string}
     * @memberof Position
     */
    file: string;
    /**
     * Folder was listened to the end
     * @type {boolean}
     * @memberof Position
     */
    folderFinished?: boolean;
    /**
     * Position in audiofile in seconds
     * @type {number}
     * @memberof Position
     */
    position: number;
}
/**
 * 
 * @export
 * @interface SearchResult
 */
export interface SearchResult {
    /**
     * Not used now, only subfolders are searched
     * @type {Array<AudioFile>}
     * @memberof SearchResult
     */
    files?: Array<AudioFile>;
    /**
     * 
     * @type {Array<Subfolder>}
     * @memberof SearchResult
     */
    subfolders?: Array<Subfolder>;
}
/**
 * 
 * @export
 * @interface SharedSecret
 */
export interface SharedSecret {
    /**
     * Salted shared secret
     * @type {string}
     * @memberof SharedSecret
     */
    secret: string;
}
/**
 * 
 * @export
 * @interface Subfolder
 */
export interface Subfolder {
    /**
     * 
     * @type {string}
     * @memberof Subfolder
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Subfolder
     */
    path: string;
    /**
     * Is virtual folder - e.g. representing big chapterized file (.m4b etc.)
     * @type {boolean}
     * @memberof Subfolder
     */
    isFile?: boolean;
    /**
     * last modification timestamp (unix time in miliseconds)
     * @type {number}
     * @memberof Subfolder
     */
    modified?: number;
    /**
     * was folder listened to the end (by given group, valid only if group parameter was provided)
     * @type {boolean}
     * @memberof Subfolder
     */
    finished?: boolean;
}
/**
 * 
 * @export
 * @interface Transcoding
 */
export interface Transcoding {
    /**
     * Name of transcoding in form of audio_codec-in-container, for instance opus-in-ogg
     * @type {string}
     * @memberof Transcoding
     */
    name: string;
    /**
     * Average bitrate of the transcoding in kbps
     * @type {number}
     * @memberof Transcoding
     */
    bitrate: number;
}
/**
 * 
 * @export
 * @interface TypedFile
 */
export interface TypedFile {
    /**
     * path to the file with collection
     * @type {string}
     * @memberof TypedFile
     */
    path: string;
    /**
     * mime type of the file
     * @type {string}
     * @memberof TypedFile
     */
    mime: string;
}
/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authentication to server via salted shared secret  Salted shared secret is calculated as:   * shared secret is encoded as UTF-8 bytes   * client generates 32 random bytes   * secret is concatenated with random bytes (secret+random_bytes)   * these bytes are hashed with SHA-256   * random bytes are encoded with base64 encoding   * hash is encoded with base64 encoding   * resulting secret is string concation of three strings : \"encoded random\" + \"|\" + \"encoded hash\"
         * @param {string} secret 
         * @param {SharedSecret} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePost(secret: string, body: SharedSecret, options: any = {}): FetchArgs {
            // verify required parameter 'secret' is not null or undefined
            if (secret === null || secret === undefined) {
                throw new RequiredError('secret','Required parameter secret was null or undefined when calling authenticatePost.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authenticatePost.');
            }
            const localVarPath = `/authenticate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (secret !== undefined) {
                localVarFormParams.set('secret', secret as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"SharedSecret" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Authentication to server via salted shared secret  Salted shared secret is calculated as:   * shared secret is encoded as UTF-8 bytes   * client generates 32 random bytes   * secret is concatenated with random bytes (secret+random_bytes)   * these bytes are hashed with SHA-256   * random bytes are encoded with base64 encoding   * hash is encoded with base64 encoding   * resulting secret is string concation of three strings : \"encoded random\" + \"|\" + \"encoded hash\"
         * @param {string} secret 
         * @param {SharedSecret} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePost(secret: string, body: SharedSecret, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).authenticatePost(secret, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Authentication to server via salted shared secret  Salted shared secret is calculated as:   * shared secret is encoded as UTF-8 bytes   * client generates 32 random bytes   * secret is concatenated with random bytes (secret+random_bytes)   * these bytes are hashed with SHA-256   * random bytes are encoded with base64 encoding   * hash is encoded with base64 encoding   * resulting secret is string concation of three strings : \"encoded random\" + \"|\" + \"encoded hash\"
         * @param {string} secret 
         * @param {SharedSecret} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePost(secret: string, body: SharedSecret, options?: any) {
            return AuthenticationApiFp(configuration).authenticatePost(secret, body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * Authentication to server via salted shared secret  Salted shared secret is calculated as:   * shared secret is encoded as UTF-8 bytes   * client generates 32 random bytes   * secret is concatenated with random bytes (secret+random_bytes)   * these bytes are hashed with SHA-256   * random bytes are encoded with base64 encoding   * hash is encoded with base64 encoding   * resulting secret is string concation of three strings : \"encoded random\" + \"|\" + \"encoded hash\"
     * @param {string} secret 
     * @param {SharedSecret} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authenticatePost(secret: string, body: SharedSecret, options?: any): Promise<string>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * Authentication to server via salted shared secret  Salted shared secret is calculated as:   * shared secret is encoded as UTF-8 bytes   * client generates 32 random bytes   * secret is concatenated with random bytes (secret+random_bytes)   * these bytes are hashed with SHA-256   * random bytes are encoded with base64 encoding   * hash is encoded with base64 encoding   * resulting secret is string concation of three strings : \"encoded random\" + \"|\" + \"encoded hash\"
     * @param {string} secret 
     * @param {SharedSecret} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticatePost(secret: string, body: SharedSecret, options?: any) {
        return AuthenticationApiFp(this.configuration).authenticatePost(secret, body, options)(this.fetch, this.basePath);
    }

}
/**
 * CollectionsApi - fetch parameter creator
 * @export
 */
export const CollectionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Streams (possibly transcoded) audio file  File is sent either directly  (in this case [http bytes range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)  is supported - but only one range per response)   or transcoded  (in this case response content is [chunck encoded](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)  and its length is not known in advance). Transcoding is triggered by query string paramater `trans`.  Typical usecase is that client loads transcoding parameters from `transcodings` endpoint  and then for each audio file decides if transcoding is required or not based on `mime` and `bitrate` values  available in folder listing.  Transcoded files can be also seek for playback start-  query string parameter `seek` can contain start of stream in seconds (related to  normal begining of file).  Plain, not transcoded files cannot be seeked in this way (they support byte ranges, which are  usually enough for a player to seek efficiently). So `seek` can be used only with `trans`.  Number of transcoding processing is limited on server, as it is lengthy and resources demanding (mainly CPU)  process. If maximum number of transcodings is already used, this endpoint will return HTTP response 503 Service Unavailable.  It's client responsibility to handle such cases. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {number} [seek] Stars playback as &lt;seek&gt; seconds from beginning of file. Beware overusing this parameter, as it can cause quite ineffective usage of bandwidth and transcoding (which each seek like this part of file from seek position is send again)
         * @param {string} [trans] Required transcoding of the file **l**ow, **m**edium or **h**igh as described by &#x60;/transcodings&#x60; endpoint response If omitted or set to **0** no transcoding is done
         * @param {string} [range] Optionally client can request range of bytes from file, will only work if file is not actually transcoded. Range is standard HTTP header as per [RFC 7233](https://datatracker.ietf.org/doc/html/rfc7233) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdAudioPathGet(colId: number, path: string, seek?: number, trans?: string, range?: string, options: any = {}): FetchArgs {
            // verify required parameter 'colId' is not null or undefined
            if (colId === null || colId === undefined) {
                throw new RequiredError('colId','Required parameter colId was null or undefined when calling colIdAudioPathGet.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling colIdAudioPathGet.');
            }
            const localVarPath = `/{col_id}/audio/{path}`
                .replace(`{${"col_id"}}`, encodeURIComponent(String(colId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (seek !== undefined) {
                localVarQueryParameter['seek'] = seek;
            }

            if (trans !== undefined) {
                localVarQueryParameter['trans'] = trans;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['range'] = String(range);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns cover image for indicated `path` (if exists) Path for cover should be taken from object returend by `folder` endpoint. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdCoverPathGet(colId: number, path: string, options: any = {}): FetchArgs {
            // verify required parameter 'colId' is not null or undefined
            if (colId === null || colId === undefined) {
                throw new RequiredError('colId','Required parameter colId was null or undefined when calling colIdCoverPathGet.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling colIdCoverPathGet.');
            }
            const localVarPath = `/{col_id}/cover/{path}`
                .replace(`{${"col_id"}}`, encodeURIComponent(String(colId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns description file (if exists) Path for description file should be taken from object returend by `folder` endpoint. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdDescPathGet(colId: number, path: string, options: any = {}): FetchArgs {
            // verify required parameter 'colId' is not null or undefined
            if (colId === null || colId === undefined) {
                throw new RequiredError('colId','Required parameter colId was null or undefined when calling colIdDescPathGet.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling colIdDescPathGet.');
            }
            const localVarPath = `/{col_id}/desc/{path}`
                .replace(`{${"col_id"}}`, encodeURIComponent(String(colId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads content of folder as an archive (zip or tar) Downloads all files (audio files, cover, description) from this folder as an archive (zip or tar).  Default format of the archive is zip, tar archive is also supported - format can be chosen by `fmt` query parameter  Also if you want to change default format by compiling audioserve with `folder-download-default-tar` feature.  This endpoint can be disabled, if audioserve is compiled without default feature `folder-download`  or with command line argument `--disable-folder-download` . 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {string} [fmt] Archive format - zip(default) or tar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdDownloadPathGet(colId: number, path: string, fmt?: string, options: any = {}): FetchArgs {
            // verify required parameter 'colId' is not null or undefined
            if (colId === null || colId === undefined) {
                throw new RequiredError('colId','Required parameter colId was null or undefined when calling colIdDownloadPathGet.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling colIdDownloadPathGet.');
            }
            const localVarPath = `/{col_id}/download/{path}`
                .replace(`{${"col_id"}}`, encodeURIComponent(String(colId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (fmt !== undefined) {
                localVarQueryParameter['fmt'] = fmt;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List contents of  root folder of the collection. See `/{col_id}/folder/{path}` for more detailed description. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
         * @param {string} [group] Playback position sharing group. If present last know position for the folder can be included in response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdFolderGet(colId: number, ord?: string, group?: string, options: any = {}): FetchArgs {
            // verify required parameter 'colId' is not null or undefined
            if (colId === null || colId === undefined) {
                throw new RequiredError('colId','Required parameter colId was null or undefined when calling colIdFolderGet.');
            }
            const localVarPath = `/{col_id}/folder/`
                .replace(`{${"col_id"}}`, encodeURIComponent(String(colId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (ord !== undefined) {
                localVarQueryParameter['ord'] = ord;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists available subfolders or audio files in the folder. Response contains arrays `files` and/or `subfolders` (each can be null or empty array).  Subfolders can be listed using this API endpoint, `files` contains playable files -   their `path` should be used with `audio` endpoint for streaming file content. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
         * @param {string} [group] Playback position sharing group. If present last know position for the folder can be included in response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdFolderPathGet(colId: number, path: string, ord?: string, group?: string, options: any = {}): FetchArgs {
            // verify required parameter 'colId' is not null or undefined
            if (colId === null || colId === undefined) {
                throw new RequiredError('colId','Required parameter colId was null or undefined when calling colIdFolderPathGet.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling colIdFolderPathGet.');
            }
            const localVarPath = `/{col_id}/folder/{path}`
                .replace(`{${"col_id"}}`, encodeURIComponent(String(colId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (ord !== undefined) {
                localVarQueryParameter['ord'] = ord;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists top 100 most recent folders in the collection (based on folder modification time).  Sorted by folder modification time descendently - e.g most recent is first. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdRecentGet(colId: number, options: any = {}): FetchArgs {
            // verify required parameter 'colId' is not null or undefined
            if (colId === null || colId === undefined) {
                throw new RequiredError('colId','Required parameter colId was null or undefined when calling colIdRecentGet.');
            }
            const localVarPath = `/{col_id}/recent`
                .replace(`{${"col_id"}}`, encodeURIComponent(String(colId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search collection - search for terms with collection paths (path only not metadata tags). Search is looking only for folders (including virtual folders for chaptered files).  Search term is split to words and each word is searched in full path (relative collection root -  the path you see in folder listing). First path that includes all words in added to results (and it's subfolders are not searched further). 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} q Search terms (separated by space). Looks for all terms on folder path. 
         * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdSearchGet(colId: number, q: string, ord?: string, options: any = {}): FetchArgs {
            // verify required parameter 'colId' is not null or undefined
            if (colId === null || colId === undefined) {
                throw new RequiredError('colId','Required parameter colId was null or undefined when calling colIdSearchGet.');
            }
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling colIdSearchGet.');
            }
            const localVarPath = `/{col_id}/search`
                .replace(`{${"col_id"}}`, encodeURIComponent(String(colId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (ord !== undefined) {
                localVarQueryParameter['ord'] = ord;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of available collections (collection is a directory provided as parameter to audioserve server).  It should be first call to server, after client authenticates itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsGet(options: any = {}): FetchArgs {
            const localVarPath = `/collections/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets current transcoding settings on the server. Server has 3 transcodings presets: `high`, `medium`, `low` (or no transcoding), between which client can choose, when  streaming audofile.  If `max_transcodings` is reached server returns `503 Service Unavailable` -  it's client responsibility to retry later. Normally should be called after `collections` call, unless client is not interested in transcoding capabilities at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodingsGet(options: any = {}): FetchArgs {
            const localVarPath = `/transcodings/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Streams (possibly transcoded) audio file  File is sent either directly  (in this case [http bytes range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)  is supported - but only one range per response)   or transcoded  (in this case response content is [chunck encoded](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)  and its length is not known in advance). Transcoding is triggered by query string paramater `trans`.  Typical usecase is that client loads transcoding parameters from `transcodings` endpoint  and then for each audio file decides if transcoding is required or not based on `mime` and `bitrate` values  available in folder listing.  Transcoded files can be also seek for playback start-  query string parameter `seek` can contain start of stream in seconds (related to  normal begining of file).  Plain, not transcoded files cannot be seeked in this way (they support byte ranges, which are  usually enough for a player to seek efficiently). So `seek` can be used only with `trans`.  Number of transcoding processing is limited on server, as it is lengthy and resources demanding (mainly CPU)  process. If maximum number of transcodings is already used, this endpoint will return HTTP response 503 Service Unavailable.  It's client responsibility to handle such cases. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {number} [seek] Stars playback as &lt;seek&gt; seconds from beginning of file. Beware overusing this parameter, as it can cause quite ineffective usage of bandwidth and transcoding (which each seek like this part of file from seek position is send again)
         * @param {string} [trans] Required transcoding of the file **l**ow, **m**edium or **h**igh as described by &#x60;/transcodings&#x60; endpoint response If omitted or set to **0** no transcoding is done
         * @param {string} [range] Optionally client can request range of bytes from file, will only work if file is not actually transcoded. Range is standard HTTP header as per [RFC 7233](https://datatracker.ietf.org/doc/html/rfc7233) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdAudioPathGet(colId: number, path: string, seek?: number, trans?: string, range?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).colIdAudioPathGet(colId, path, seek, trans, range, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns cover image for indicated `path` (if exists) Path for cover should be taken from object returend by `folder` endpoint. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdCoverPathGet(colId: number, path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).colIdCoverPathGet(colId, path, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns description file (if exists) Path for description file should be taken from object returend by `folder` endpoint. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdDescPathGet(colId: number, path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).colIdDescPathGet(colId, path, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Downloads content of folder as an archive (zip or tar) Downloads all files (audio files, cover, description) from this folder as an archive (zip or tar).  Default format of the archive is zip, tar archive is also supported - format can be chosen by `fmt` query parameter  Also if you want to change default format by compiling audioserve with `folder-download-default-tar` feature.  This endpoint can be disabled, if audioserve is compiled without default feature `folder-download`  or with command line argument `--disable-folder-download` . 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {string} [fmt] Archive format - zip(default) or tar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdDownloadPathGet(colId: number, path: string, fmt?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).colIdDownloadPathGet(colId, path, fmt, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List contents of  root folder of the collection. See `/{col_id}/folder/{path}` for more detailed description. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
         * @param {string} [group] Playback position sharing group. If present last know position for the folder can be included in response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdFolderGet(colId: number, ord?: string, group?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AudioFolder> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).colIdFolderGet(colId, ord, group, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists available subfolders or audio files in the folder. Response contains arrays `files` and/or `subfolders` (each can be null or empty array).  Subfolders can be listed using this API endpoint, `files` contains playable files -   their `path` should be used with `audio` endpoint for streaming file content. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
         * @param {string} [group] Playback position sharing group. If present last know position for the folder can be included in response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdFolderPathGet(colId: number, path: string, ord?: string, group?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AudioFolder> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).colIdFolderPathGet(colId, path, ord, group, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists top 100 most recent folders in the collection (based on folder modification time).  Sorted by folder modification time descendently - e.g most recent is first. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdRecentGet(colId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchResult> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).colIdRecentGet(colId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search collection - search for terms with collection paths (path only not metadata tags). Search is looking only for folders (including virtual folders for chaptered files).  Search term is split to words and each word is searched in full path (relative collection root -  the path you see in folder listing). First path that includes all words in added to results (and it's subfolders are not searched further). 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} q Search terms (separated by space). Looks for all terms on folder path. 
         * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdSearchGet(colId: number, q: string, ord?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchResult> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).colIdSearchGet(colId, q, ord, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns list of available collections (collection is a directory provided as parameter to audioserve server).  It should be first call to server, after client authenticates itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).collectionsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets current transcoding settings on the server. Server has 3 transcodings presets: `high`, `medium`, `low` (or no transcoding), between which client can choose, when  streaming audofile.  If `max_transcodings` is reached server returns `503 Service Unavailable` -  it's client responsibility to retry later. Normally should be called after `collections` call, unless client is not interested in transcoding capabilities at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodingsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).transcodingsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Streams (possibly transcoded) audio file  File is sent either directly  (in this case [http bytes range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)  is supported - but only one range per response)   or transcoded  (in this case response content is [chunck encoded](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)  and its length is not known in advance). Transcoding is triggered by query string paramater `trans`.  Typical usecase is that client loads transcoding parameters from `transcodings` endpoint  and then for each audio file decides if transcoding is required or not based on `mime` and `bitrate` values  available in folder listing.  Transcoded files can be also seek for playback start-  query string parameter `seek` can contain start of stream in seconds (related to  normal begining of file).  Plain, not transcoded files cannot be seeked in this way (they support byte ranges, which are  usually enough for a player to seek efficiently). So `seek` can be used only with `trans`.  Number of transcoding processing is limited on server, as it is lengthy and resources demanding (mainly CPU)  process. If maximum number of transcodings is already used, this endpoint will return HTTP response 503 Service Unavailable.  It's client responsibility to handle such cases. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {number} [seek] Stars playback as &lt;seek&gt; seconds from beginning of file. Beware overusing this parameter, as it can cause quite ineffective usage of bandwidth and transcoding (which each seek like this part of file from seek position is send again)
         * @param {string} [trans] Required transcoding of the file **l**ow, **m**edium or **h**igh as described by &#x60;/transcodings&#x60; endpoint response If omitted or set to **0** no transcoding is done
         * @param {string} [range] Optionally client can request range of bytes from file, will only work if file is not actually transcoded. Range is standard HTTP header as per [RFC 7233](https://datatracker.ietf.org/doc/html/rfc7233) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdAudioPathGet(colId: number, path: string, seek?: number, trans?: string, range?: string, options?: any) {
            return CollectionsApiFp(configuration).colIdAudioPathGet(colId, path, seek, trans, range, options)(fetch, basePath);
        },
        /**
         * Returns cover image for indicated `path` (if exists) Path for cover should be taken from object returend by `folder` endpoint. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdCoverPathGet(colId: number, path: string, options?: any) {
            return CollectionsApiFp(configuration).colIdCoverPathGet(colId, path, options)(fetch, basePath);
        },
        /**
         * Returns description file (if exists) Path for description file should be taken from object returend by `folder` endpoint. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdDescPathGet(colId: number, path: string, options?: any) {
            return CollectionsApiFp(configuration).colIdDescPathGet(colId, path, options)(fetch, basePath);
        },
        /**
         * Downloads content of folder as an archive (zip or tar) Downloads all files (audio files, cover, description) from this folder as an archive (zip or tar).  Default format of the archive is zip, tar archive is also supported - format can be chosen by `fmt` query parameter  Also if you want to change default format by compiling audioserve with `folder-download-default-tar` feature.  This endpoint can be disabled, if audioserve is compiled without default feature `folder-download`  or with command line argument `--disable-folder-download` . 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {string} [fmt] Archive format - zip(default) or tar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdDownloadPathGet(colId: number, path: string, fmt?: string, options?: any) {
            return CollectionsApiFp(configuration).colIdDownloadPathGet(colId, path, fmt, options)(fetch, basePath);
        },
        /**
         * List contents of  root folder of the collection. See `/{col_id}/folder/{path}` for more detailed description. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
         * @param {string} [group] Playback position sharing group. If present last know position for the folder can be included in response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdFolderGet(colId: number, ord?: string, group?: string, options?: any) {
            return CollectionsApiFp(configuration).colIdFolderGet(colId, ord, group, options)(fetch, basePath);
        },
        /**
         * Lists available subfolders or audio files in the folder. Response contains arrays `files` and/or `subfolders` (each can be null or empty array).  Subfolders can be listed using this API endpoint, `files` contains playable files -   their `path` should be used with `audio` endpoint for streaming file content. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
         * @param {string} [group] Playback position sharing group. If present last know position for the folder can be included in response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdFolderPathGet(colId: number, path: string, ord?: string, group?: string, options?: any) {
            return CollectionsApiFp(configuration).colIdFolderPathGet(colId, path, ord, group, options)(fetch, basePath);
        },
        /**
         * Lists top 100 most recent folders in the collection (based on folder modification time).  Sorted by folder modification time descendently - e.g most recent is first. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdRecentGet(colId: number, options?: any) {
            return CollectionsApiFp(configuration).colIdRecentGet(colId, options)(fetch, basePath);
        },
        /**
         * Search collection - search for terms with collection paths (path only not metadata tags). Search is looking only for folders (including virtual folders for chaptered files).  Search term is split to words and each word is searched in full path (relative collection root -  the path you see in folder listing). First path that includes all words in added to results (and it's subfolders are not searched further). 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} q Search terms (separated by space). Looks for all terms on folder path. 
         * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colIdSearchGet(colId: number, q: string, ord?: string, options?: any) {
            return CollectionsApiFp(configuration).colIdSearchGet(colId, q, ord, options)(fetch, basePath);
        },
        /**
         * Returns list of available collections (collection is a directory provided as parameter to audioserve server).  It should be first call to server, after client authenticates itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsGet(options?: any) {
            return CollectionsApiFp(configuration).collectionsGet(options)(fetch, basePath);
        },
        /**
         * Gets current transcoding settings on the server. Server has 3 transcodings presets: `high`, `medium`, `low` (or no transcoding), between which client can choose, when  streaming audofile.  If `max_transcodings` is reached server returns `503 Service Unavailable` -  it's client responsibility to retry later. Normally should be called after `collections` call, unless client is not interested in transcoding capabilities at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcodingsGet(options?: any) {
            return CollectionsApiFp(configuration).transcodingsGet(options)(fetch, basePath);
        },
    };
};

/**
 * CollectionsApi - interface
 * @export
 * @interface CollectionsApi
 */
export interface CollectionsApiInterface {
    /**
     * Streams (possibly transcoded) audio file  File is sent either directly  (in this case [http bytes range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)  is supported - but only one range per response)   or transcoded  (in this case response content is [chunck encoded](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)  and its length is not known in advance). Transcoding is triggered by query string paramater `trans`.  Typical usecase is that client loads transcoding parameters from `transcodings` endpoint  and then for each audio file decides if transcoding is required or not based on `mime` and `bitrate` values  available in folder listing.  Transcoded files can be also seek for playback start-  query string parameter `seek` can contain start of stream in seconds (related to  normal begining of file).  Plain, not transcoded files cannot be seeked in this way (they support byte ranges, which are  usually enough for a player to seek efficiently). So `seek` can be used only with `trans`.  Number of transcoding processing is limited on server, as it is lengthy and resources demanding (mainly CPU)  process. If maximum number of transcodings is already used, this endpoint will return HTTP response 503 Service Unavailable.  It's client responsibility to handle such cases. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {number} [seek] Stars playback as &lt;seek&gt; seconds from beginning of file. Beware overusing this parameter, as it can cause quite ineffective usage of bandwidth and transcoding (which each seek like this part of file from seek position is send again)
     * @param {string} [trans] Required transcoding of the file **l**ow, **m**edium or **h**igh as described by &#x60;/transcodings&#x60; endpoint response If omitted or set to **0** no transcoding is done
     * @param {string} [range] Optionally client can request range of bytes from file, will only work if file is not actually transcoded. Range is standard HTTP header as per [RFC 7233](https://datatracker.ietf.org/doc/html/rfc7233) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApiInterface
     */
    colIdAudioPathGet(colId: number, path: string, seek?: number, trans?: string, range?: string, options?: any): Promise<Blob>;

    /**
     * Returns cover image for indicated `path` (if exists) Path for cover should be taken from object returend by `folder` endpoint. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApiInterface
     */
    colIdCoverPathGet(colId: number, path: string, options?: any): Promise<Blob>;

    /**
     * Returns description file (if exists) Path for description file should be taken from object returend by `folder` endpoint. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApiInterface
     */
    colIdDescPathGet(colId: number, path: string, options?: any): Promise<string>;

    /**
     * Downloads content of folder as an archive (zip or tar) Downloads all files (audio files, cover, description) from this folder as an archive (zip or tar).  Default format of the archive is zip, tar archive is also supported - format can be chosen by `fmt` query parameter  Also if you want to change default format by compiling audioserve with `folder-download-default-tar` feature.  This endpoint can be disabled, if audioserve is compiled without default feature `folder-download`  or with command line argument `--disable-folder-download` . 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {string} [fmt] Archive format - zip(default) or tar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApiInterface
     */
    colIdDownloadPathGet(colId: number, path: string, fmt?: string, options?: any): Promise<Blob>;

    /**
     * List contents of  root folder of the collection. See `/{col_id}/folder/{path}` for more detailed description. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
     * @param {string} [group] Playback position sharing group. If present last know position for the folder can be included in response 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApiInterface
     */
    colIdFolderGet(colId: number, ord?: string, group?: string, options?: any): Promise<AudioFolder>;

    /**
     * Lists available subfolders or audio files in the folder. Response contains arrays `files` and/or `subfolders` (each can be null or empty array).  Subfolders can be listed using this API endpoint, `files` contains playable files -   their `path` should be used with `audio` endpoint for streaming file content. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
     * @param {string} [group] Playback position sharing group. If present last know position for the folder can be included in response 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApiInterface
     */
    colIdFolderPathGet(colId: number, path: string, ord?: string, group?: string, options?: any): Promise<AudioFolder>;

    /**
     * Lists top 100 most recent folders in the collection (based on folder modification time).  Sorted by folder modification time descendently - e.g most recent is first. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApiInterface
     */
    colIdRecentGet(colId: number, options?: any): Promise<SearchResult>;

    /**
     * Search collection - search for terms with collection paths (path only not metadata tags). Search is looking only for folders (including virtual folders for chaptered files).  Search term is split to words and each word is searched in full path (relative collection root -  the path you see in folder listing). First path that includes all words in added to results (and it's subfolders are not searched further). 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} q Search terms (separated by space). Looks for all terms on folder path. 
     * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApiInterface
     */
    colIdSearchGet(colId: number, q: string, ord?: string, options?: any): Promise<SearchResult>;

    /**
     * Returns list of available collections (collection is a directory provided as parameter to audioserve server).  It should be first call to server, after client authenticates itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApiInterface
     */
    collectionsGet(options?: any): Promise<InlineResponse200>;

    /**
     * Gets current transcoding settings on the server. Server has 3 transcodings presets: `high`, `medium`, `low` (or no transcoding), between which client can choose, when  streaming audofile.  If `max_transcodings` is reached server returns `503 Service Unavailable` -  it's client responsibility to retry later. Normally should be called after `collections` call, unless client is not interested in transcoding capabilities at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApiInterface
     */
    transcodingsGet(options?: any): Promise<InlineResponse2001>;

}

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI implements CollectionsApiInterface {
    /**
     * Streams (possibly transcoded) audio file  File is sent either directly  (in this case [http bytes range](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)  is supported - but only one range per response)   or transcoded  (in this case response content is [chunck encoded](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)  and its length is not known in advance). Transcoding is triggered by query string paramater `trans`.  Typical usecase is that client loads transcoding parameters from `transcodings` endpoint  and then for each audio file decides if transcoding is required or not based on `mime` and `bitrate` values  available in folder listing.  Transcoded files can be also seek for playback start-  query string parameter `seek` can contain start of stream in seconds (related to  normal begining of file).  Plain, not transcoded files cannot be seeked in this way (they support byte ranges, which are  usually enough for a player to seek efficiently). So `seek` can be used only with `trans`.  Number of transcoding processing is limited on server, as it is lengthy and resources demanding (mainly CPU)  process. If maximum number of transcodings is already used, this endpoint will return HTTP response 503 Service Unavailable.  It's client responsibility to handle such cases. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {number} [seek] Stars playback as &lt;seek&gt; seconds from beginning of file. Beware overusing this parameter, as it can cause quite ineffective usage of bandwidth and transcoding (which each seek like this part of file from seek position is send again)
     * @param {string} [trans] Required transcoding of the file **l**ow, **m**edium or **h**igh as described by &#x60;/transcodings&#x60; endpoint response If omitted or set to **0** no transcoding is done
     * @param {string} [range] Optionally client can request range of bytes from file, will only work if file is not actually transcoded. Range is standard HTTP header as per [RFC 7233](https://datatracker.ietf.org/doc/html/rfc7233) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public colIdAudioPathGet(colId: number, path: string, seek?: number, trans?: string, range?: string, options?: any) {
        return CollectionsApiFp(this.configuration).colIdAudioPathGet(colId, path, seek, trans, range, options)(this.fetch, this.basePath);
    }

    /**
     * Returns cover image for indicated `path` (if exists) Path for cover should be taken from object returend by `folder` endpoint. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public colIdCoverPathGet(colId: number, path: string, options?: any) {
        return CollectionsApiFp(this.configuration).colIdCoverPathGet(colId, path, options)(this.fetch, this.basePath);
    }

    /**
     * Returns description file (if exists) Path for description file should be taken from object returend by `folder` endpoint. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public colIdDescPathGet(colId: number, path: string, options?: any) {
        return CollectionsApiFp(this.configuration).colIdDescPathGet(colId, path, options)(this.fetch, this.basePath);
    }

    /**
     * Downloads content of folder as an archive (zip or tar) Downloads all files (audio files, cover, description) from this folder as an archive (zip or tar).  Default format of the archive is zip, tar archive is also supported - format can be chosen by `fmt` query parameter  Also if you want to change default format by compiling audioserve with `folder-download-default-tar` feature.  This endpoint can be disabled, if audioserve is compiled without default feature `folder-download`  or with command line argument `--disable-folder-download` . 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {string} [fmt] Archive format - zip(default) or tar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public colIdDownloadPathGet(colId: number, path: string, fmt?: string, options?: any) {
        return CollectionsApiFp(this.configuration).colIdDownloadPathGet(colId, path, fmt, options)(this.fetch, this.basePath);
    }

    /**
     * List contents of  root folder of the collection. See `/{col_id}/folder/{path}` for more detailed description. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
     * @param {string} [group] Playback position sharing group. If present last know position for the folder can be included in response 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public colIdFolderGet(colId: number, ord?: string, group?: string, options?: any) {
        return CollectionsApiFp(this.configuration).colIdFolderGet(colId, ord, group, options)(this.fetch, this.basePath);
    }

    /**
     * Lists available subfolders or audio files in the folder. Response contains arrays `files` and/or `subfolders` (each can be null or empty array).  Subfolders can be listed using this API endpoint, `files` contains playable files -   their `path` should be used with `audio` endpoint for streaming file content. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
     * @param {string} [group] Playback position sharing group. If present last know position for the folder can be included in response 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public colIdFolderPathGet(colId: number, path: string, ord?: string, group?: string, options?: any) {
        return CollectionsApiFp(this.configuration).colIdFolderPathGet(colId, path, ord, group, options)(this.fetch, this.basePath);
    }

    /**
     * Lists top 100 most recent folders in the collection (based on folder modification time).  Sorted by folder modification time descendently - e.g most recent is first. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public colIdRecentGet(colId: number, options?: any) {
        return CollectionsApiFp(this.configuration).colIdRecentGet(colId, options)(this.fetch, this.basePath);
    }

    /**
     * Search collection - search for terms with collection paths (path only not metadata tags). Search is looking only for folders (including virtual folders for chaptered files).  Search term is split to words and each word is searched in full path (relative collection root -  the path you see in folder listing). First path that includes all words in added to results (and it's subfolders are not searched further). 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} q Search terms (separated by space). Looks for all terms on folder path. 
     * @param {string} [ord] ordering of subfolders, two values are now supported: - &#x60;a&#x60; alphabetical (default if not present) - &#x60;m&#x60; recent first (using folder mtime)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public colIdSearchGet(colId: number, q: string, ord?: string, options?: any) {
        return CollectionsApiFp(this.configuration).colIdSearchGet(colId, q, ord, options)(this.fetch, this.basePath);
    }

    /**
     * Returns list of available collections (collection is a directory provided as parameter to audioserve server).  It should be first call to server, after client authenticates itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionsGet(options?: any) {
        return CollectionsApiFp(this.configuration).collectionsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Gets current transcoding settings on the server. Server has 3 transcodings presets: `high`, `medium`, `low` (or no transcoding), between which client can choose, when  streaming audofile.  If `max_transcodings` is reached server returns `503 Service Unavailable` -  it's client responsibility to retry later. Normally should be called after `collections` call, unless client is not interested in transcoding capabilities at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public transcodingsGet(options?: any) {
        return CollectionsApiFp(this.configuration).transcodingsGet(options)(this.fetch, this.basePath);
    }

}
/**
 * PositionsApi - fetch parameter creator
 * @export
 */
export const PositionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Last recent position for given folder path (`path` can be empty to for root of collection,  but in this case / must be present after  `col_id`` ). If `rec` query parameter is given recursive search is done for this folder and all subfolders and list of postions is returned.
         * @param {string} group Playback position sharing group. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {boolean} [finished] Filters only positions for finished folders
         * @param {boolean} [unfinished] Filters only positions for unfinished folders
         * @param {number} [from] Filters positions that are older than this timestamp  (unix time in ms)
         * @param {number} [to] Filters positions that are newer or equal than this timestamp  (unix time in ms)
         * @param {boolean} [rec] Recursively look for all subdirectories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupColIdPathGet(group: string, colId: number, path: string, finished?: boolean, unfinished?: boolean, from?: number, to?: number, rec?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling positionsGroupColIdPathGet.');
            }
            // verify required parameter 'colId' is not null or undefined
            if (colId === null || colId === undefined) {
                throw new RequiredError('colId','Required parameter colId was null or undefined when calling positionsGroupColIdPathGet.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling positionsGroupColIdPathGet.');
            }
            const localVarPath = `/positions/{group}/{col_id}/{path}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"col_id"}}`, encodeURIComponent(String(colId)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (finished !== undefined) {
                localVarQueryParameter['finished'] = finished;
            }

            if (unfinished !== undefined) {
                localVarQueryParameter['unfinished'] = unfinished;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (rec !== undefined) {
                localVarQueryParameter['rec'] = rec;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent positions for the group
         * @param {string} group Playback position sharing group. 
         * @param {boolean} [finished] Filters only positions for finished folders
         * @param {boolean} [unfinished] Filters only positions for unfinished folders
         * @param {number} [from] Filters positions that are older than this timestamp  (unix time in ms)
         * @param {number} [to] Filters positions that are newer or equal than this timestamp  (unix time in ms)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupGet(group: string, finished?: boolean, unfinished?: boolean, from?: number, to?: number, options: any = {}): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling positionsGroupGet.');
            }
            const localVarPath = `/positions/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (finished !== undefined) {
                localVarQueryParameter['finished'] = finished;
            }

            if (unfinished !== undefined) {
                localVarQueryParameter['unfinished'] = unfinished;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Last recent position for this group
         * @param {string} group Playback position sharing group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupLastGet(group: string, options: any = {}): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling positionsGroupLastGet.');
            }
            const localVarPath = `/positions/{group}/last`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates recent position for given group
         * @param {Position} body 
         * @param {string} group Playback position sharing group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupPost(body: Position, group: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling positionsGroupPost.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling positionsGroupPost.');
            }
            const localVarPath = `/positions/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Position" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PositionsApi - functional programming interface
 * @export
 */
export const PositionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Last recent position for given folder path (`path` can be empty to for root of collection,  but in this case / must be present after  `col_id`` ). If `rec` query parameter is given recursive search is done for this folder and all subfolders and list of postions is returned.
         * @param {string} group Playback position sharing group. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {boolean} [finished] Filters only positions for finished folders
         * @param {boolean} [unfinished] Filters only positions for unfinished folders
         * @param {number} [from] Filters positions that are older than this timestamp  (unix time in ms)
         * @param {number} [to] Filters positions that are newer or equal than this timestamp  (unix time in ms)
         * @param {boolean} [rec] Recursively look for all subdirectories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupColIdPathGet(group: string, colId: number, path: string, finished?: boolean, unfinished?: boolean, from?: number, to?: number, rec?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = PositionsApiFetchParamCreator(configuration).positionsGroupColIdPathGet(group, colId, path, finished, unfinished, from, to, rec, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get recent positions for the group
         * @param {string} group Playback position sharing group. 
         * @param {boolean} [finished] Filters only positions for finished folders
         * @param {boolean} [unfinished] Filters only positions for unfinished folders
         * @param {number} [from] Filters positions that are older than this timestamp  (unix time in ms)
         * @param {number} [to] Filters positions that are newer or equal than this timestamp  (unix time in ms)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupGet(group: string, finished?: boolean, unfinished?: boolean, from?: number, to?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Position>> {
            const localVarFetchArgs = PositionsApiFetchParamCreator(configuration).positionsGroupGet(group, finished, unfinished, from, to, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Last recent position for this group
         * @param {string} group Playback position sharing group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupLastGet(group: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Position> {
            const localVarFetchArgs = PositionsApiFetchParamCreator(configuration).positionsGroupLastGet(group, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates recent position for given group
         * @param {Position} body 
         * @param {string} group Playback position sharing group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupPost(body: Position, group: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PositionsApiFetchParamCreator(configuration).positionsGroupPost(body, group, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PositionsApi - factory interface
 * @export
 */
export const PositionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Last recent position for given folder path (`path` can be empty to for root of collection,  but in this case / must be present after  `col_id`` ). If `rec` query parameter is given recursive search is done for this folder and all subfolders and list of postions is returned.
         * @param {string} group Playback position sharing group. 
         * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
         * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
         * @param {boolean} [finished] Filters only positions for finished folders
         * @param {boolean} [unfinished] Filters only positions for unfinished folders
         * @param {number} [from] Filters positions that are older than this timestamp  (unix time in ms)
         * @param {number} [to] Filters positions that are newer or equal than this timestamp  (unix time in ms)
         * @param {boolean} [rec] Recursively look for all subdirectories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupColIdPathGet(group: string, colId: number, path: string, finished?: boolean, unfinished?: boolean, from?: number, to?: number, rec?: boolean, options?: any) {
            return PositionsApiFp(configuration).positionsGroupColIdPathGet(group, colId, path, finished, unfinished, from, to, rec, options)(fetch, basePath);
        },
        /**
         * Get recent positions for the group
         * @param {string} group Playback position sharing group. 
         * @param {boolean} [finished] Filters only positions for finished folders
         * @param {boolean} [unfinished] Filters only positions for unfinished folders
         * @param {number} [from] Filters positions that are older than this timestamp  (unix time in ms)
         * @param {number} [to] Filters positions that are newer or equal than this timestamp  (unix time in ms)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupGet(group: string, finished?: boolean, unfinished?: boolean, from?: number, to?: number, options?: any) {
            return PositionsApiFp(configuration).positionsGroupGet(group, finished, unfinished, from, to, options)(fetch, basePath);
        },
        /**
         * Last recent position for this group
         * @param {string} group Playback position sharing group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupLastGet(group: string, options?: any) {
            return PositionsApiFp(configuration).positionsGroupLastGet(group, options)(fetch, basePath);
        },
        /**
         * Updates recent position for given group
         * @param {Position} body 
         * @param {string} group Playback position sharing group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionsGroupPost(body: Position, group: string, options?: any) {
            return PositionsApiFp(configuration).positionsGroupPost(body, group, options)(fetch, basePath);
        },
    };
};

/**
 * PositionsApi - interface
 * @export
 * @interface PositionsApi
 */
export interface PositionsApiInterface {
    /**
     * Last recent position for given folder path (`path` can be empty to for root of collection,  but in this case / must be present after  `col_id`` ). If `rec` query parameter is given recursive search is done for this folder and all subfolders and list of postions is returned.
     * @param {string} group Playback position sharing group. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {boolean} [finished] Filters only positions for finished folders
     * @param {boolean} [unfinished] Filters only positions for unfinished folders
     * @param {number} [from] Filters positions that are older than this timestamp  (unix time in ms)
     * @param {number} [to] Filters positions that are newer or equal than this timestamp  (unix time in ms)
     * @param {boolean} [rec] Recursively look for all subdirectories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApiInterface
     */
    positionsGroupColIdPathGet(group: string, colId: number, path: string, finished?: boolean, unfinished?: boolean, from?: number, to?: number, rec?: boolean, options?: any): Promise<InlineResponse2002>;

    /**
     * Get recent positions for the group
     * @param {string} group Playback position sharing group. 
     * @param {boolean} [finished] Filters only positions for finished folders
     * @param {boolean} [unfinished] Filters only positions for unfinished folders
     * @param {number} [from] Filters positions that are older than this timestamp  (unix time in ms)
     * @param {number} [to] Filters positions that are newer or equal than this timestamp  (unix time in ms)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApiInterface
     */
    positionsGroupGet(group: string, finished?: boolean, unfinished?: boolean, from?: number, to?: number, options?: any): Promise<Array<Position>>;

    /**
     * Last recent position for this group
     * @param {string} group Playback position sharing group. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApiInterface
     */
    positionsGroupLastGet(group: string, options?: any): Promise<Position>;

    /**
     * Updates recent position for given group
     * @param {Position} body 
     * @param {string} group Playback position sharing group. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApiInterface
     */
    positionsGroupPost(body: Position, group: string, options?: any): Promise<{}>;

}

/**
 * PositionsApi - object-oriented interface
 * @export
 * @class PositionsApi
 * @extends {BaseAPI}
 */
export class PositionsApi extends BaseAPI implements PositionsApiInterface {
    /**
     * Last recent position for given folder path (`path` can be empty to for root of collection,  but in this case / must be present after  `col_id`` ). If `rec` query parameter is given recursive search is done for this folder and all subfolders and list of postions is returned.
     * @param {string} group Playback position sharing group. 
     * @param {number} colId id of collection, is index of collection from &#x60;names&#x60; array returned by &#x60;/collections&#x60; endpoint
     * @param {string} path path to the item (as returned in by API, do not forget to urlencode the value)
     * @param {boolean} [finished] Filters only positions for finished folders
     * @param {boolean} [unfinished] Filters only positions for unfinished folders
     * @param {number} [from] Filters positions that are older than this timestamp  (unix time in ms)
     * @param {number} [to] Filters positions that are newer or equal than this timestamp  (unix time in ms)
     * @param {boolean} [rec] Recursively look for all subdirectories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    public positionsGroupColIdPathGet(group: string, colId: number, path: string, finished?: boolean, unfinished?: boolean, from?: number, to?: number, rec?: boolean, options?: any) {
        return PositionsApiFp(this.configuration).positionsGroupColIdPathGet(group, colId, path, finished, unfinished, from, to, rec, options)(this.fetch, this.basePath);
    }

    /**
     * Get recent positions for the group
     * @param {string} group Playback position sharing group. 
     * @param {boolean} [finished] Filters only positions for finished folders
     * @param {boolean} [unfinished] Filters only positions for unfinished folders
     * @param {number} [from] Filters positions that are older than this timestamp  (unix time in ms)
     * @param {number} [to] Filters positions that are newer or equal than this timestamp  (unix time in ms)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    public positionsGroupGet(group: string, finished?: boolean, unfinished?: boolean, from?: number, to?: number, options?: any) {
        return PositionsApiFp(this.configuration).positionsGroupGet(group, finished, unfinished, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * Last recent position for this group
     * @param {string} group Playback position sharing group. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    public positionsGroupLastGet(group: string, options?: any) {
        return PositionsApiFp(this.configuration).positionsGroupLastGet(group, options)(this.fetch, this.basePath);
    }

    /**
     * Updates recent position for given group
     * @param {Position} body 
     * @param {string} group Playback position sharing group. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PositionsApi
     */
    public positionsGroupPost(body: Position, group: string, options?: any) {
        return PositionsApiFp(this.configuration).positionsGroupPost(body, group, options)(this.fetch, this.basePath);
    }

}
